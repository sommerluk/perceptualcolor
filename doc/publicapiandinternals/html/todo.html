<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PerceptualColor: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PerceptualColor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('todo.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Page <a class="el" href="build.html">Build instructions and requirements</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000073"></a>Is Qt&#160;5.6 actually enough?. Even if so, wouldn’t it be better to require the last LTS&#160;release (5.15), just to be compatible if in the future we depend on this?</p>
<p class="interdd"><a class="anchor" id="_todo000074"></a>Provide detailed build instructions.</p>
<p class="enddd"><a class="anchor" id="_todo000075"></a>Provide a CMake find module for this library and install it.  </p>
</dd>
<dt>File <a class="el" href="helper_8h.html">helper.h</a>  </dt>
<dd><a class="anchor" id="_todo000017"></a>Decide for each member of this namespace if it can be moved into a class because it’s only used in this single class.  </dd>
<dt>page <a class="el" href="index.html">Main Page</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000021"></a>Actually set up a localization!</p>
<p class="interdd"><a class="anchor" id="_todo000022"></a>General library properties:</p><ul>
<li>test cross-platform support and different byte-orders</li>
<li>Could we interate more with QStyle?</li>
<li>stylable by style sheets (✗)</li>
<li>More work on accessibility. [This includes to work well with bigger fonts. Should then the gradient be thicker and the marker thicker? setAccessibleName().]</li>
</ul>
<p class="interdd"><a class="anchor" id="_todo000023"></a>From KDE’s binary compatibility info page: In order to make a class to extend in the future you should follow these rules:</p><ul>
<li>add d-pointer. See below.</li>
<li>add non-inline virtual destructor even if the body is empty.</li>
<li>reimplement event in QObject-derived classes, even if the body for the function is just calling the base class' implementation. This is specifically to avoid problems caused by adding a reimplemented virtual function as discussed below.</li>
<li>make all constructors non-inline.</li>
<li>write non-inline implementations of the copy constructor and assignment operator unless the class cannot be copied by value (e.g. classes inherited from QObject can't be)</li>
</ul>
<p class="interdd"><a class="anchor" id="_todo000024"></a>Where possible: Make the pimpl inherit from <code>public QObject</code> to allow to get rid of lambdas in the connect statements.</p>
<p class="interdd"><a class="anchor" id="_todo000025"></a>In <a href="https://phabricator.kde.org/T12359">https://phabricator.kde.org/T12359</a> is recommanded to provide RESET statements for all properties for better compatibility with QML. As we provide widgets, this should not be too important. Are there also good arguments for widgets to provide RESET?</p>
<p class="interdd"><a class="anchor" id="_todo000026"></a>Provide an init() function that calls qRegisterMetaType() for all our types?</p>
<p class="interdd"><a class="anchor" id="_todo000027"></a>Support i18n language change and/or locale change on-the-fly?</p>
<p class="interdd"><a class="anchor" id="_todo000028"></a>We prevent division by 0 in <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram_1_1_chroma_lightness_diagram_private.html#a388784a7986fdf0867e6364044c3dcdd">PerceptualColor::ChromaLightnessDiagram::ChromaLightnessDiagramPrivate::fromWidgetPixelPositionToColor()</a>. We should make sure this happens also in the other diagram widgets!</p>
<p class="interdd"><a class="anchor" id="_todo000029"></a>Add a <a class="el" href="class_perceptual_color_1_1_const_propagating_unique_pointer.html">PerceptualColor::ConstPropagatingUniquePointer</a> to all classes, including the non-pimpl classes, to allow for later enhancements.</p>
<p class="interdd"><a class="anchor" id="_todo000030"></a>Remove setDevicePixelRatioF from all *Image classes. (It is confusing, and at the same time there is no real need/benefit.) Complete list: <a class="el" href="class_perceptual_color_1_1_chroma_hue_image.html">PerceptualColor::ChromaHueImage</a>, <a class="el" href="class_perceptual_color_1_1_color_wheel_image.html">PerceptualColor::ColorWheelImage</a>, <a class="el" href="class_perceptual_color_1_1_gradient_image.html">PerceptualColor::GradientImage</a>.</p>
<p class="interdd"><a class="anchor" id="_todo000031"></a>Test also on Windows. (Does it work well with VisualStudio? Isn’t there a free version of VisualStudio? Test it with this library!)</p>
<p class="interdd"><a class="anchor" id="_todo000032"></a>Test opaque RGB color space object with a non-export-all version of this library to make sure it actually works for third-party developers.</p>
<p class="interdd"><a class="anchor" id="_todo000033"></a>Sometimes, on dual-screen setup, one screen has another DPI than the other screen. Does this library behave correctly in these situations?</p>
<p class="interdd"><a class="anchor" id="_todo000034"></a>Would it make sense for <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">PerceptualColor::ChromaHueDiagram</a> and <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">PerceptualColor::ChromaLightnessDiagram</a> to split up their property <code>currentColor</code> into two properties: A two-dimensional property for what the user can change, and a one-dimensional property for what only the programmer can change? Or at least provide a Q_INVOKABLE getter and maybe also setter support? So <a class="el" href="class_perceptual_color_1_1_wheel_color_picker.html">PerceptualColor::WheelColorPicker</a> could use this instead of a lambda expression to set the hue of the <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">PerceptualColor::ChromaLightnessDiagram</a>. And: Also when we don’t do that: When setting <code>currentColor</code> to an out-of-gamut color, what happens? Does <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">PerceptualColor::ChromaHueDiagram</a> preserve lightness, while <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">PerceptualColor::ChromaLightnessDiagram</a> preserves hue? Would this make sense?</p>
<p class="interdd"><a class="anchor" id="_todo000035"></a>Paint grayed-out handles for all widgets when setEnabled(false) is used! For example 25% lightness instead of black. And 75% lightness instead of white. But: Provide this information in <a class="el" href="class_perceptual_color_1_1_abstract_diagram.html">PerceptualColor::AbstractDiagram</a>!</p>
<p class="interdd"><a class="anchor" id="_todo000036"></a>Provide a link to (the online version of) this page in README.md&lt;p&gt; <a class="anchor" id="_todo000037"></a>The doxygen documentation should not recommand <code>filename.h</code> but <code>PerceptualColor/filename.h</code>!?</p>
<p class="interdd"><a class="anchor" id="_todo000038"></a>Review and unit tests for these classes: <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">PerceptualColor::ChromaLightnessDiagram</a>, <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html">PerceptualColor::RgbColorSpace</a> <br  />
</p>
<p class="interdd"><a class="anchor" id="_todo000039"></a>It might be interesting to use <code>QStyle::PM_FocusFrameHMargin</code> <em>(Horizontal margin that the focus frame will outset the widget by.)</em> Or: <code>QStyle::PM_FocusFrameVMargin</code>. Using this for the distance between the focus indicator and the actual content of the widget maybe give a more <code>QStyle</code> compliant look. But: If using this, ensurePolished() must be called before!</p>
<p class="interdd"><a class="anchor" id="_todo000040"></a>Use <code>explicit</code> on all constructors?</p>
<p class="interdd"><a class="anchor" id="_todo000041"></a>Screen picker with magnifier glass in two steps similar to <a href="https://colorsnapper.com">https://colorsnapper.com</a> ?</p>
<p class="interdd"><a class="anchor" id="_todo000042"></a>Multi-licensing? Add Boost licence and Unlicense as an additional choise?</p>
<p class="interdd"><a class="anchor" id="_todo000043"></a>The image cache for the gamut widgets should be updated asynchronously (in its own thread or even various own threads in parallel). While waiting for the result, an empty image could be used. Or it might be useful to provide first a low-resolution version, and only later-on a high-resolution version. Anyway, KDE provides an interesting recommandation: <code>int Units::humanMoment = 2000;</code> <em>Time in milliseconds equivalent to the theoretical human moment, which can be used to determine whether how long to wait until the user should be informed of something, or can be used as the limit for how long something should wait before being automatically initiated. / Some examples: / When the user types text in a search field, wait no longer than this duration after the user completes typing before starting the search / When loading data which would commonly arrive rapidly enough to not require interaction, wait this long before showing a spinner</em> See <a href="https://api.kde.org/frameworks/plasma-framework/html/classUnits.html#ab22ad7033b2e3d00a862650e82f5ba5e">https://api.kde.org/frameworks/plasma-framework/html/classUnits.html#ab22ad7033b2e3d00a862650e82f5ba5e</a> for details.</p>
<p class="interdd"><a class="anchor" id="_todo000044"></a>HLC <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">PerceptualColor::MultiSpinBox</a> Allow entering (on the keyboard) of too big hues (361°), negatif hues (-1°), negatif chroma (-20) and too big chroma (201 or 256) – but do not allow this with the arrows (and how do the arrows react when currently one of these values is shown?). Does this make sense? Anyway do <em>not</em> allow this for lightness, because the lightness is <em>by definition</em> bound to <code>[0,&#160;100]</code>.</p>
<p class="interdd"><a class="anchor" id="_todo000045"></a>Multi-threaded application of color transforms. It seems okay to create the color transforms in one thread and use the same color transform (once created) from various other threads at the same time as long as the flag <code>cmsFLAGS_NOCACHE</code> is used to create the transform.</p>
<p class="interdd"><a class="anchor" id="_todo000046"></a>Automatically scale the thickness of the wheel (and maybe even the handle) with varying widget size?</p>
<p class="interdd"><a class="anchor" id="_todo000047"></a>Support more color spaces? <a href="https://pypi.org/project/colorio/">https://pypi.org/project/colorio/</a> for example supports a lot of (also perceptually uniform) color spaces…</p>
<p class="interdd"><a class="anchor" id="_todo000048"></a>Export lesss symbols?</p>
<p class="interdd"><a class="anchor" id="_todo000049"></a>Check in all classes that take a <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html">PerceptualColor::RgbColorSpace</a> that the shared pointer is actually not a <code>nullptr</code>. If is <em>is</em> a <code>nullptr</code> than throw an exception. Throwing the exception early might make error detection easier for users of the library.</p>
<p class="interdd"><a class="anchor" id="_todo000050"></a>Avoid default arguments like <code>void test(int i = 0)</code> in public headers, as changes require re-compilation of the client application to take effect, which might lead to a miss-match of behaviour between application and library, if compile-time and run-time version of the library are not the same. Is the problem for default constructors like <code>ClassName() = default</code> similar?</p>
<p class="interdd"><a class="anchor" id="_todo000051"></a>mark all public non-slot functions with Q_INVOKABLE (except property setters and getters)</p>
<p class="interdd"><a class="anchor" id="_todo000052"></a>A good widget library should also be touchscreen-ready. Find an alternative to <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">PerceptualColor::MultiSpinBox</a>? How, for up to 360 values (degrees in step by 1)? Or should the steps simply be bigger?</p>
<p class="interdd"><a class="anchor" id="_todo000053"></a>KDE Frameworks / <a href="https://marketplace.qt.io/">https://marketplace.qt.io/</a> ? <a href="https://community.kde.org/Incubator">https://community.kde.org/Incubator</a></p>
<p class="interdd"><a class="anchor" id="_todo000054"></a>Provide property bindings as described in <a href="https://www.qt.io/blog/property-bindings-in-qt-6">https://www.qt.io/blog/property-bindings-in-qt-6</a> or not? It is worth when we do not support QML? What are the pitfalls? Imagine a property that holds a percent value from&#160;0&#160;to&#160;100; the setter enforces this range; the binding bypasses the setter and allows every value? And: How can callbacks know about when a setter was called in C++? See also: <a href="https://doc.qt.io/qt-5/qtqml-cppintegration-exposecppattributes.html">https://doc.qt.io/qt-5/qtqml-cppintegration-exposecppattributes.html</a> and <a href="https://doc.qt.io/qt-5/qtqml-tutorials-extending-qml-example.html">https://doc.qt.io/qt-5/qtqml-tutorials-extending-qml-example.html</a> and <a href="http://blog.aeguana.com/2015/12/12/writing-a-gui-using-qml-for-a-c-project/">http://blog.aeguana.com/2015/12/12/writing-a-gui-using-qml-for-a-c-project/</a> for interaction between QML and C++. Pitfalls: Example of color() property stored internally at m_color: Much implementation code of the clas will access directly m_color instead of color(), so when using bindings, this code is broken?</p>
<p class="interdd"><a class="anchor" id="_todo000055"></a>Provide QML support so that for <a href="https://doc.qt.io/qt-5/qml-qtquick-dialogs-colordialog.html">https://doc.qt.io/qt-5/qml-qtquick-dialogs-colordialog.html</a> (or its Qt6 counterpart) we provide a source compatible alternative, like for QColorWidget? Split the library in three parts (Common, Widgets, QML)?</p>
<p class="interdd"><a class="anchor" id="_todo000056"></a>Apparently QWidget cannot be used from QML. (Though there is <a href="https://www.kdab.com/declarative-widgets/">https://www.kdab.com/declarative-widgets/</a> – how does that work?) Is it therefore worth to have complete support for signals in all our QWidget code if this is not really necessary for QWidget (for example for properties that can only be changed programatically and not by the user)?</p>
<p class="interdd"><a class="anchor" id="_todo000057"></a>Comply with KDE policies: <a href="https://community.kde.org/Policies">https://community.kde.org/Policies</a></p>
<p class="interdd"><a class="anchor" id="_todo000058"></a>Remove all qDebug calls from the source</p>
<p class="interdd"><a class="anchor" id="_todo000059"></a>Use QObject::tr() for translations. Provide po files? How can a library be localized? See <a href="https://community.kde.org/Frameworks/Frameworks_Localization_Policy">https://community.kde.org/Frameworks/Frameworks_Localization_Policy</a> for ideas.</p>
<p class="interdd"><a class="anchor" id="_todo000060"></a>Translations: Color picker/Select Color → Farbwähler/Farbauswahl etc…</p>
<p class="interdd"><a class="anchor" id="_todo000061"></a>Qt Designer support for the widgets. Quote from a blog from Viking about Qt Designer plugins: The problem is that you have to build it with exactly the same compiler tool chain as designer was built with, and you have to do it in release mode. Unless your Qt is built in debug, then your plugin needs to be built in debug mode as well. So you can’t just always use the same compiler as you build the application with, if you use the system Qt or a downloaded Qt version.</p>
<p class="interdd"><a class="anchor" id="_todo000062"></a>Use <a href="https://lvc.github.io/abi-compliance-checker/">abi-compliance-checker</a> to control ABI compatibility.</p>
<p class="interdd"><a class="anchor" id="_todo000063"></a>Follow KDE’s <a href="https://hig.kde.org/index.html">HIG</a></p>
<p class="interdd"><a class="anchor" id="_todo000064"></a>Test linking against lcms.h in version 2.0.0 for compatibility (or require more recent version?)</p>
<p class="interdd"><a class="anchor" id="_todo000065"></a>Require (by static cast additional to CMake conditions) a minimum Qt version?</p>
<p class="interdd"><a class="anchor" id="_todo000066"></a>Would it be a good idea to implement Q_PROPERTY RESET overall? See also <a href="https://phabricator.kde.org/T12359">https://phabricator.kde.org/T12359</a></p>
<p class="interdd"><a class="anchor" id="_todo000067"></a>Better design on small widget sizes for the whole library.</p>
<p class="interdd"><a class="anchor" id="_todo000068"></a>Anti-aliasing the gamut diagrams? Wouldn't this be bad for performance?</p>
<p class="interdd"><a class="anchor" id="_todo000069"></a>Use a cross-hair cursor on <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">PerceptualColor::ChromaHueDiagram</a> and <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">PerceptualColor::ChromaLightnessDiagram</a> when the mouse is hovering over the gamut, to show that this surface can be clicked?</p>
<p class="interdd"><a class="anchor" id="_todo000070"></a>Touch-friendly interface: Would it be good to have buttons for plus and minus on the various LCH axis which would be companings for <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">PerceptualColor::ChromaHueDiagram</a> and <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">PerceptualColor::ChromaLightnessDiagram</a> and would allow more exactly choose colors also on touch devices?</p>
<p class="interdd"><a class="anchor" id="_todo000071"></a>Would it be a good idea to have plus and minus buttons that manipulate the current color along the depth and vividness axis as proposed in “Extending CIELAB - Vividness, V, depth, D, and clarity, T” by Roy S. Berns?</p>
<p class="enddd"><a class="anchor" id="_todo000072"></a>Spell checking for the documentation, if possible also grammar checking with LanguageTool  </p>
</dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_abstract_diagram.html">PerceptualColor::AbstractDiagram</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000084"></a>Circular diagrams should be right-aligned on RTL layouts.</p>
<p class="enddd"><a class="anchor" id="_todo000085"></a>Touchscreen support: Magnify the handle circle, when diagram is used on a touch device? <br  />
  </p>
</dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">PerceptualColor::ChromaHueDiagram</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000086"></a>BUG Left-click in the gray area inside the wheel but outside the displayed gammut; maintain the click button and do not move the mouse. Actual behavior: Mouse curser is invisible. Expected behaviour: Mouse cursor stays visible (as it would be anyway after moving the mouse).</p>
<p class="interdd"><a class="anchor" id="_todo000087"></a>BUG Click on the wheel. Actual behaviour: Nothing. Expected behavior: The selected color follows the cursor.</p>
<p class="interdd"><a class="anchor" id="_todo000088"></a>Example code: How to create the widget at a given lightness.</p>
<p class="interdd"><a class="anchor" id="_todo000089"></a>Allow to touch the widget on the color wheel (and have a reaction).</p>
<p class="interdd"><a class="anchor" id="_todo000090"></a>Use a cross cursor for better usability: The cross cursor indicates to the user that an area can be clicked in. Do it only within the gamut (where the color handle can actually go) or in the hole gray circle, which is the mouse sensitive area (but out of the gamut the color handle cannot follow)?</p>
<p class="interdd"><a class="anchor" id="_todo000091"></a>Support additional mouse buttons. For example, “forward” and “backward” could be used to increase or decrease the radial.</p>
<p class="interdd"><a class="anchor" id="_todo000092"></a>What if black or white are out of gamut on L=0.1 or L=99.9? Where are the handles placed? Visible or invisible? How to react? Should there be always a physical pixel in the middle that is visible (black or white) even when out of gamut?</p>
<p class="enddd"><a class="anchor" id="_todo000093"></a>Optimization: It might be possible to <em>not</em> store both, a <a class="el" href="class_perceptual_color_1_1_chroma_hue_image.html">ChromaHueImage</a> and a <a class="el" href="class_perceptual_color_1_1_color_wheel_image.html">ColorWheelImage</a>, but only one. This would cut the memory usage of this class to the half. <a class="el" href="class_perceptual_color_1_1_color_wheel_image.html">ColorWheelImage</a> would not be stored anymore. Instead, <a class="el" href="class_perceptual_color_1_1_chroma_hue_image.html">ChromaHueImage</a> would be modified to contain also the color wheel. When the lightness changes, <a class="el" href="class_perceptual_color_1_1_chroma_hue_image.html">ChromaHueImage</a> does not delete the cache, but (later) adjusts only the inner circle with the chroma-hue diagram. It would be a little bit tricky to get right the extreme positions (maximum chroma) because of the anti-aliasing at these positions: We would have to cut out (without anti-aliasing) enough surface to be able to draw again an anti-aliased circle above a completly transparent place.  </p>
</dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram_1_1_chroma_hue_diagram_private.html#a03c7215226afe4ca2aecee045ee68d7b">PerceptualColor::ChromaHueDiagram::ChromaHueDiagramPrivate::setColorFromWidgetPixelPosition</a>  (const QPoint position)</dt>
<dd><a class="anchor" id="_todo000003"></a>What when the mouse goes outside the gray circle, but more gamut is available outside (because <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html#a60d9c4b82875039e2b16b179ec649fea">RgbColorSpace::maximumChroma()</a> was chosen too small)? For consistency, the handle of the diagram should stay within the gray circle, and this should be interpretat also actually as the value at the position of the handle.  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html#a896cd3a826210cf78a39e3cbbdbc34f8">PerceptualColor::ChromaHueDiagram::keyPressEvent</a>  (QKeyEvent *event) override</dt>
<dd><a class="anchor" id="_todo000002"></a>Is this behavior really a good user experience? Or is it confusing that left, right, up and down don’t do what was expected? What could be more intuitive keys for changing radial and angle? At least the arrow keys are likely that the user tries them out by trial-and-error.  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html#adfe93a3ac0005a23c03465635089d846">PerceptualColor::ChromaHueDiagram::mouseReleaseEvent</a>  (QMouseEvent *event) override</dt>
<dd><a class="anchor" id="_todo000001"></a>What if the widget displays a gamut that has no L*=0.1 because its blackpoint is lighter.? Sacrifying chroma alone does not help? How to react (for mouse input, keyboard input, but also API functions like setColor()?  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html#ad7709d55647d4a6842f34a5dd10cb2a9">PerceptualColor::ChromaHueDiagram::paintEvent</a>  (QPaintEvent *event) override</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000004"></a>Show the indicator on the color wheel not only while a mouse button is pressed, but also while a keyboard button is pressed.</p>
<p class="enddd"><a class="anchor" id="_todo000005"></a>What when <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram_1_1_chroma_hue_diagram_private.html#ad09de14751dae747c777feb9965bc387">ChromaHueDiagramPrivate::m_currentColor</a> has a valid in-gamut color, but this color is out of the <em>displayed</em> diagram? How to handle that?  </p>
</dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">PerceptualColor::ChromaLightnessDiagram</a>  </dt>
<dd><a class="anchor" id="_todo000010"></a>What to do if a gamut allows lightness &lt; 0 or lightness &gt; 100 ??? What if a part of the gamut at the right is not displayed? (Thought this means that <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html">RgbColorSpace</a> has a bug.) Shouldn’t this be controlled?) Maybe it would be better to control this within <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html">RgbColorSpace</a> …  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram_1_1_chroma_lightness_diagram_private.html#a10e575e8f37fda3da08bc3e51c176d7f">PerceptualColor::ChromaLightnessDiagram::ChromaLightnessDiagramPrivate::isWidgetPixelPositionInGamut</a>  (const QPoint widgetPixelPosition) const</dt>
<dd><a class="anchor" id="_todo000008"></a>How does isInGamut() react? Does it also control valid chroma and lightness ranges?  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html#abd23775803f181201fefbdcc08378ab8">PerceptualColor::ChromaLightnessDiagram::keyPressEvent</a>  (QKeyEvent *event) override</dt>
<dd><a class="anchor" id="_todo000007"></a>Is the current behaviour (when pressing right arrow while yet at the right border of the gamut, also the lightness is adjusted to allow moving actually to the right) really a good idea? Andway, it has a bug, and arrow-down does not work on blue hues because the gamut has some sort of corner, and there, the curser blocks.  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html#aa0aa6d31cefd3b9dfbfe9acfcac18e3d">PerceptualColor::ChromaLightnessDiagram::mousePressEvent</a>  (QMouseEvent *event) override</dt>
<dd><a class="anchor" id="_todo000006"></a>This widget reacts on mouse press events also when they occur within the border. It might be nice if it would not. On the other hand: The border is small. Would it really be worth the pain to implement this?  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html#a00220aed4a26b01305e64dfdb9a3124a">PerceptualColor::ChromaLightnessDiagram::setCurrentColor</a>  (const <a class="el" href="struct_perceptual_color_1_1_lch_double.html" title="A LCH color.">PerceptualColor::LchDouble</a> &amp;newCurrentColor)</dt>
<dd><a class="anchor" id="_todo000009"></a>When an out-of-gamut color is given, both lightness and chroma are adjusted. But does this really make sense? In <a class="el" href="class_perceptual_color_1_1_wheel_color_picker.html">WheelColorPicker</a>, when using the hue wheel, also <em>both</em>, lightness <em>and</em> chroma will change. Isn’t that confusing?  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_chroma_lightness_image.html#a11064cef0d42fdb7a07b4508d19db79b">PerceptualColor::ChromaLightnessImage::setBackgroundColor</a>  (const QColor newBackgroundColor)</dt>
<dd><a class="anchor" id="_todo000011"></a>This function should become obsolete once <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html">RgbColorSpace</a> does not rely anymore on an image to find nearest in-gamut colors.  </dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_color_dialog.html">PerceptualColor::ColorDialog</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000094"></a>Make sure that <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">ChromaHueDiagram</a> always shows at least at the central physical pixel with an in-gamut color. Solution: Limit the range of the lightness selector? Or a better algorithm in <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">ChromaHueDiagram</a>?</p>
<p class="interdd"><a class="anchor" id="_todo000095"></a>Provide (on demand) two patches, like Scribus also does: One for the old color (cannot be modified by the user) and another one for the new color (same behavior as the yet existing color patch). One could be named “before” and the other “after”. Or maybe make this configurable? And put an arrow between the patches, from “before” to “after”. (Be aware: RTL support necessary!)</p>
<p class="interdd"><a class="anchor" id="_todo000096"></a>The HLC widget accepts values that are out-of-gamut; the dialog shows the nearest in-gamut color during this moment. Also, the RGB Hex widget accepts intermediatly invalid values (for example, 4-digit-values); the dialog displays the last previously displayed valid color during this moment. Those two situations do not have consiteend behaviour, but there are no good alternatives. However: Would it make sense to keep this behaviour, but display in the <a class="el" href="class_perceptual_color_1_1_color_patch.html">ColorPatch</a> an empty value during editing an out-of-gamut HLC value or an invalid RGB Hex values?</p>
<p class="interdd"><a class="anchor" id="_todo000097"></a>For the tab widget, use rather icons instead of the text “hue-baded” and “lightness-based”!?</p>
<p class="interdd"><a class="anchor" id="_todo000098"></a>Provide <code>setWhatsThis()</code> help for widgets. Or tool tips? Or both? What is more appropriate? Or use both? For <a class="el" href="class_perceptual_color_1_1_wheel_color_picker.html">WheelColorPicker</a> and <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">ChromaLightnessDiagram</a>, this help text could describe the keyboard controls and be integrated as default value in the class itself. For the other widgets, a help text could be defined here within <em>this</em> class, if appropriate.</p>
<p class="interdd"><a class="anchor" id="_todo000099"></a>Touch screen compatibility: In general: What would mean better support for touch-screen and convertible? More things to do? For example, A spin box can also be used on mobile phone (putting the numbers with on-screen keyboard). But the + and - button for increasing or decreasing the values might be too small. And mobile UI uses often wheels for this use case…</p>
<p class="interdd"><a class="anchor" id="_todo000100"></a>The QLineEdit for the hexadecimal RGB values should change lower-case letters on-the-fly (as-you-type) to upper-case letters. And: Maybe it could even be switched to <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a> (but that would mean implement support for hexadecimal digits in <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a>).</p>
<p class="interdd"><a class="anchor" id="_todo000101"></a>Accept <code>F5</code> and <code>Ctrl+R</code> just with the same functionality as the refresh button in the HCL <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a>. But attention: If a library user <em>embeds</em> the dialog, he does not want his shortcuts to be intercepted!</p>
<p class="interdd"><a class="anchor" id="_todo000102"></a>It might be nice to support keyboard shortcuts for switching tabs like in browsers, which is a concept many users might be familiar to. Crtl+Tab to switch to the next tab in the list. Crtl+Shift+Tab to switch to the previous tab in the list.</p>
<p class="interdd"><a class="anchor" id="_todo000103"></a>Start with dialog with Qt::yellow. You get HLC 100° 98% 95. Push the apply button. Actual result: HLC 100° 98% 94 which has a slightly different chroma value. Expected result: Ideally there would be no rounding difference at all: Every once displayed value is always recognized as valid. When the color space conversion takes place, we could (and should) make this sure for HLC values. But then comes the also the rounding in <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a>. Is there any solution?</p>
<p class="interdd"><a class="anchor" id="_todo000104"></a>If there is no alpha widget <em>and</em> the actual layout is expanded (either explicitly by <a class="el" href="class_perceptual_color_1_1_color_dialog.html#aacdc2037c54daa56d8e0d0132ca5361ea1a6130a21d7d578d81a168ebcf0d9921">DialogLayoutDimensions::expanded</a> or implicitly by <a class="el" href="class_perceptual_color_1_1_color_dialog.html#aacdc2037c54daa56d8e0d0132ca5361eaa9c08d97fbc8ac7a9ab2f64d96dfd636">DialogLayoutDimensions::screenSizeDependent</a> on bigger screens) <em>than</em> it would make sense to move the <a class="el" href="class_perceptual_color_1_1_color_dialog_1_1_color_dialog_private.html#a02bd53c415f8a6cfe759a695f65e5836">ColorDialogPrivate::m_buttonBox</a> into the same column as the <a class="el" href="class_perceptual_color_1_1_color_dialog_1_1_color_dialog_private.html#a7497daac98f2e54677be6451bd050801">ColorDialogPrivate::m_numericalWidget</a>, namely <em>below</em> the <a class="el" href="class_perceptual_color_1_1_color_dialog_1_1_color_dialog_private.html#a7497daac98f2e54677be6451bd050801">ColorDialogPrivate::m_numericalWidget</a>. This saves screen space and does not confuse the user.</p>
<p class="interdd"><a class="anchor" id="_todo000105"></a>Provide an overloaded version of <a class="el" href="class_perceptual_color_1_1_color_dialog.html#a28ba2d1ec20acc6a732d8fbe60f9fbd4">open()</a> that accepts arguments for new-style connect statements, making use of compiler checks.</p>
<p class="interdd"><a class="anchor" id="_todo000106"></a>Use the <em>actual</em> color profile of the monitor.</p>
<p class="interdd"><a class="anchor" id="_todo000107"></a>The LCh-hue (and so the graphical widgets) jumps forward and backward when changing RGB-based values (also HSV) when entering and leaving the gray axis, due to lack of hue information. Would it be an option to store the old hue to get a meaningful hue? Should it be only really for the gray axis, or allow a certain tolerance around the gray axis is necessary to make this work well - and if so, how much tolerance? Would it be useful to define a certain hue, for example 0°, as default hue for when no old hue is available but the new value is on the gray axis?</p>
<p class="interdd"><a class="anchor" id="_todo000108"></a>Custom layout management that has a specific height-per-width ratio considering the <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">ChromaHueDiagram</a> and and <a class="el" href="class_perceptual_color_1_1_wheel_color_picker.html">WheelColorPicker</a> and <em>their</em> useful height-per-width ratio.</p>
<p class="interdd"><a class="anchor" id="_todo000109"></a>Support for other models like HSL (HSB is yet identical to HSV?), Munsell? With an option to enable or disable them? (NCS not, because it is not free…)</p>
<p class="interdd"><a class="anchor" id="_todo000110"></a>Would CMYK support make sense? Would it integrate intuitively into the user interface? If we would have CMYK support, we would have two different profiles (RGB and CMYK) active simultaniously. Which one is the profile that defines the available color space? Would this be intuitive? Also, when using two different profiles, it will be possible to have out-of-gamut colors in one of the profiles. How to represent this in the UI?</p>
<p class="interdd"><a class="anchor" id="_todo000111"></a>Provide palettes? Include there a palette with QColorDialog’s standard colors as RGB values without a specific color space, with the name “Default”? Add <a href="https://www.w3.org/TR/css-color-4/#named-colors">CSS&#160;colors</a> as defined as sRGB values? <a href="https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors">Web-save&#160;colors</a> (but with another name, maybe “216&#160;colors”) as bigger palette, without a specific color space – does not make sense, since we provide a perceptual color dialog, which allows things much beyond 216 colors, and 216 colors isn’t a useful standard anymore, and not a nice palette either.</p>
<p class="enddd"><a class="anchor" id="_todo000112"></a>Instead of (or additional to) palettes: Discret widgets, that have a fixed (quite limited) number of fields to chose for the user?  </p>
</dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_color_patch.html">PerceptualColor::ColorPatch</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000113"></a>Base this class on <a class="el" href="class_perceptual_color_1_1_abstract_diagram.html">AbstractDiagram</a> to be future-proof? We could draw the frame with QStyle…</p>
<p class="enddd"><a class="anchor" id="_todo000114"></a>The design does not work well on some styles (wrong metrics!)  </p>
</dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_color_wheel.html">PerceptualColor::ColorWheel</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000115"></a>Add support for Qt::MouseButton::BackButton? (Typically present on the 'thumb' side of a mouse with extra buttons. This is NOT the tilt wheel.) Add support for Qt::MouseButton::ForwardButton? (Typically present beside the 'Back' button, and also pressed by the thumb.)</p>
<p class="enddd"><a class="anchor" id="_todo000116"></a>What when some of the wheel colors are out of gamut? How to handle that?  </p>
</dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_color_wheel.html#af9239c2d314dfae0cdea05d3af6e2454">PerceptualColor::ColorWheel::keyPressEvent</a>  (QKeyEvent *event) override</dt>
<dd><a class="anchor" id="_todo000012"></a>The keys are chosen to not conflict with <a class="el" href="class_perceptual_color_1_1_chroma_hue_diagram.html">ChromaHueDiagram</a>. But: They are a little strange. Does this really make sense?  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_color_wheel.html#a1cf469af7cb823baaebe9bdc03f34218">PerceptualColor::ColorWheel::paintEvent</a>  (QPaintEvent *event) override</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000013"></a>Make the wheel to be drawn horizontally and vertically aligned?? Or better top-left aligned for LTR layouts and top-right aligned for RTL layouts?</p>
<p class="enddd"><a class="anchor" id="_todo000014"></a>Better design (smaller wheel ribbon?) for small widget sizes  </p>
</dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_color_wheel_image.html#a407d4e56ad56f82771b7de647b3de27b">PerceptualColor::ColorWheelImage::getImage</a>  ()</dt>
<dd><a class="anchor" id="_todo000015"></a>Out-of-gamut situations should automatically be handled.  </dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_const_propagating_unique_pointer.html">PerceptualColor::ConstPropagatingUniquePointer&lt; T &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000117"></a>Would it be better to include (or link to) <a href="https://github.com/jbcoe/propagate_const">https://github.com/jbcoe/propagate_const</a> instead of having our own implementation? Or remove propagate_const header from this library?  </dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_gradient_slider.html">PerceptualColor::GradientSlider</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000118"></a>A better handle for the slider. Currently, the handle is just a line. At a handle position at the very beginning or end of the slider, furthermore only half of the line thickness is visible. It might be better to have arrows outside the slider to mark the position. (On the other hand, this would be different to the slider handles of the color wheels…)</p>
<p class="interdd"><a class="anchor" id="_todo000119"></a>A better focus indicator. Some example code is commented out in the implementation of <a class="el" href="class_perceptual_color_1_1_gradient_slider.html#af77975f736888c4e3d1492ec224e02ed">paintEvent()</a>.</p>
<p class="enddd"><a class="anchor" id="_todo000120"></a>This class <a class="el" href="class_perceptual_color_1_1_gradient_slider.html">GradientSlider</a> and also the class <a class="el" href="class_perceptual_color_1_1_color_wheel.html">ColorWheel</a> could be subclasses of QAbstractSlider. This might integrate better with the user’s Qt code. On the other hand, this would mean a lot of work in this library to implement the complete interface of QAbstractSlider, and probably we would also need multiple inheritence because this class also depends on <a class="el" href="class_perceptual_color_1_1_abstract_diagram.html">AbstractDiagram</a> which is itself yet a subclass of QWidget.  </p>
</dd>
<dt>Class <a class="el" href="struct_perceptual_color_1_1_lcha_double.html">PerceptualColor::LchaDouble</a>  </dt>
<dd><a class="anchor" id="_todo000121"></a>We could normalize <a class="el" href="struct_perceptual_color_1_1_lcha_double.html">LchaDouble</a> values, just like <a class="el" href="class_perceptual_color_1_1_polar_point_f.html">PolarPointF</a> also does. Performance should not matter for this use case! But: Does it make sense?  </dd>
<dt>Class <a class="el" href="struct_perceptual_color_1_1_lch_double.html">PerceptualColor::LchDouble</a>  </dt>
<dd><a class="anchor" id="_todo000122"></a>Would it make sense to normalize the hue (1° instead of 361°, and only non-negatif radials) and/or to bound the <a class="el" href="struct_perceptual_color_1_1_lch_double.html#a699c9cd585fcf5e4dba577860e66bd37">l</a> component to the range <code>[0, 100]</code> and/or to bound the radial to the range <code>[0, 255]</code> or <code>[0, <a class="el" href="struct_perceptual_color_1_1_lch_values.html#a913b8d01b3e68aa09358e2b2c2c59324">LchValues::humanMaximumChroma</a>]</code>?  </dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_multi_color.html">PerceptualColor::MultiColor</a>  </dt>
<dd><a class="anchor" id="_todo000076"></a>Conversion HSV-RGB with Qt’s QColor: Can we get a higher precison with our own implementation?  </dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">PerceptualColor::MultiSpinBox</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000123"></a><code>Crtl-A</code> support for this class. (Does this shortcut trigger <code>selectAll()</code>?) <code>Ctrl-U</code> support for this class? If so, do it via <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html#abf4ec5c1f4519cbb44badbd84ac9dc3b">clear()</a>. And: It the user tries to delete everything, delete instead only the current value!? (By the way: How does QDateTimeEdit handle this?)</p>
<p class="interdd"><a class="anchor" id="_todo000124"></a>Do really not text-cursor-select more than <em>one</em> value when editing (or do not allow text selection at all)?? Also: Selecting text with the mouse cursor seems somewhat impredictable</p>
<p class="interdd"><a class="anchor" id="_todo000125"></a>Bug: In <a class="el" href="class_perceptual_color_1_1_color_dialog.html">ColorDialog</a>, choose a tab with one of the diagrams. Then, switch back the the “numeric“ tab. Expected behaviour: When a <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a> gets back the focus, always the first section should be <em>highligted/selected</em>, independent from what was selected or the cursor position before the <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a> lost the focus. (While <code>QSpinBox</code> and <code>QDoubleSpinBox</code> don’t do that either, <code>QDateTimeEdit</code> indeed <em>does</em>, and that seems appropriate also for <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a>.</p>
<p class="interdd"><a class="anchor" id="_todo000126"></a>Bug: Enter HLC values like “<code>80.</code>” or “<code>80,</code>” or “<code>80e</code>”. Depending on the locale, it is possible to actually enter these characters, but apparently on validation it is not accepted and the value is replaced by <code>0</code>. <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html" title="A spin box that can hold multiple sections (each with its own value) at the same time.">MultiSpinBox</a> should never become 0 because the validator allows something that the converter cannot convert!</p>
<p class="interdd"><a class="anchor" id="_todo000127"></a>Now, <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html#a6f8b1c07706cefe655c838bbbb8c44bf">setSectionValues</a> does not select automatically the first section anymore. Is this in conformance with <code>QDateTimeEdit</code>? Test: Change the value in the middle. Push “Apply” button. Now, the curser is at the end of the spin box, but the active section is still the one in the middle (you can try this by using your mouse wheel on the widget).</p>
<p class="interdd"><a class="anchor" id="_todo000128"></a>Currently, if the widget has <em>not</em> the focus but the mouse moves over it and the scroll wheel is used, it’s the first section that will be changed, and not the one where the mouse is, as the user might expect. Even QDateTimeEdit does the same thing (thus they do not change the first section, but the last one that was editig before). But it would be great if we could do better here. But: Is this realistic and will the required code work on all platforms?</p>
<p class="interdd"><a class="anchor" id="_todo000129"></a>When adding Bengali digits (for example by copy and paste) to a <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html">MultiSpinBox</a> that was localized to en_US, than sometimes this is accepted (thought later “corrected” to 0), and sometimes not. This behaviour is inconsistend and wrong.</p>
<p class="enddd"><a class="anchor" id="_todo000130"></a>Apparently, the validator doesn’t restict the input actually to the given range. For QDoubleSpinBox however, the line edit <em>is</em> restricted! Example: even if 100&#160;is maximum, it is possible to write&#160;444. Maybe our <a class="el" href="class_perceptual_color_1_1_extended_double_validator.html">ExtendedDoubleValidator</a> should not rely on Qt’s validator, but on if QLocale is able to convert (result: valid) or not (result: invalid)?!.  </p>
</dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_multi_spin_box.html#a6f8b1c07706cefe655c838bbbb8c44bf">PerceptualColor::MultiSpinBox::setSectionValues</a>  (const QList&lt; double &gt; &amp;newSectionValues)</dt>
<dd><a class="anchor" id="_todo000077"></a>TODO Before, we had: <em>The first section will be selected as new current section.</em> We did this by calling <a class="el" href="class_perceptual_color_1_1_multi_spin_box_1_1_multi_spin_box_private.html#a4155696c14a4c8e48e6b559c6ef6cdeb">MultiSpinBoxPrivate::setCurrentIndexAndUpdateTextAndSelectValue()</a>. Now, this isn’t possible anymore because the function is used much more in our code which expects this not to chagne…  </dd>
<dt>Member <a class="el" href="namespace_perceptual_color.html#acba80173d5ace34e255dc659e5ae10d1">PerceptualColor::operator&lt;&lt;</a>  (QDebug dbg, const <a class="el" href="struct_perceptual_color_1_1_lcha_double.html" title="A LCH color with alpha channel.">PerceptualColor::LchaDouble</a> &amp;value)</dt>
<dd><a class="anchor" id="_todo000019"></a>This is originally declared in the global namespace instead of the <a class="el" href="namespace_perceptual_color.html">PerceptualColor</a> namespace, because the supported value was a <code>typedef</code> for a LittleCMS type in the global; when declaring this function in <a class="el" href="namespace_perceptual_color.html">PerceptualColor</a> namespace, it did not work in the global namespace. Now, things have changed. But we should write a unit test for if it works in global namespace!  </dd>
<dt>Member <a class="el" href="namespace_perceptual_color.html#a8cdce06372d388f685024b40b1d67ebd">PerceptualColor::operator&lt;&lt;</a>  (QDebug dbg, const <a class="el" href="struct_perceptual_color_1_1_lch_double.html" title="A LCH color.">PerceptualColor::LchDouble</a> &amp;value)</dt>
<dd><a class="anchor" id="_todo000020"></a>This is originally declared in the global namespace instead of the <a class="el" href="namespace_perceptual_color.html">PerceptualColor</a> namespace, because the supported value was a <code>typedef</code> for a LittleCMS type in the global; when declaring this function in <a class="el" href="namespace_perceptual_color.html">PerceptualColor</a> namespace, it did not work in the global namespace. Now, things have changed. But we should write a unit test for if it works in global namespace!  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_refresh_icon_engine.html#a4ea3fd600230f5580cf59c8f4592cad3">PerceptualColor::RefreshIconEngine::paintFallbackIcon</a>  (QPainter *painter, const QRect rect, QIcon::Mode mode)</dt>
<dd><a class="anchor" id="_todo000078"></a>Provide a real design for this icon, and not just a circle. </dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html">PerceptualColor::RgbColorSpace</a>  </dt>
<dd><a class="anchor" id="_todo000082"></a>We return double precision values. But doesn’t use LittleCMS only 16-bit-integer internally? On the other hand: Using double precision allows to filter out out-of-range values…  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html#a4e05a8cbf8cede1773b45260f3302af0">PerceptualColor::RgbColorSpace::nearestInGamutColorByAdjustingChroma</a>  (const <a class="el" href="struct_perceptual_color_1_1_lch_double.html" title="A LCH color.">PerceptualColor::LchDouble</a> &amp;color) const</dt>
<dd><a class="anchor" id="_todo000081"></a>This function should never change anything than chroma. If it fails, it should throw an exception.  </dd>
<dt>Member <a class="el" href="class_perceptual_color_1_1_rgb_color_space_1_1_rgb_color_space_private.html#aabb3eca2fc20da7304ff03b34eb1584c">PerceptualColor::RgbColorSpace::RgbColorSpacePrivate::deleteTransform</a>  (cmsHTRANSFORM &amp;transformHandle)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000079"></a>TODO Use pointer instead of reference as argument to make sure that the caller sees that this function changes the argument.</p>
<p class="enddd"><a class="anchor" id="_todo000080"></a>TODO Implement a similar function to delete profiles!  </p>
</dd>
<dt>Class <a class="el" href="struct_perceptual_color_1_1_rgb_double.html">PerceptualColor::RgbDouble</a>  </dt>
<dd><a class="anchor" id="_todo000083"></a>This data type is only used within <a class="el" href="class_perceptual_color_1_1_rgb_color_space.html">RgbColorSpace</a>. It is not part of the public API. Therefore, it seems more appropriate to either delete it entirely (substituting its usage by an array of three elements with LittleCMS data type) or keep it, but use consequently LittleCMS for the unterlying data and make unit tests with LittleCMS to be sure it behaves as expected, also when used as a buffer.  </dd>
<dt>Member <a class="el" href="namespace_perceptual_color.html#ac23b3b01908951b41ac4f04568018f5d">PerceptualColor::singleStepHue</a>  </dt>
<dd><a class="anchor" id="_todo000018"></a>What would be a good value for this? Its effect depends on chroma: On higher chroma, the same step in hue means a bigger visual color difference. We could even calculate that, but it does not seem to be very intuitive if the reaction on mouse wheel events are different depending on chroma - that would not be easy to understand for the user. And it might be better that the user this way also notices intuitively that hue changes are not linear across chroma. Anyway: What would be a sensible default step?  </dd>
<dt>Member <a class="el" href="namespace_perceptual_color.html#a5511785d9a42b0b012cc43d31231bccd">PerceptualColor::transparencyBackground</a>  (qreal devicePixelRatioF)</dt>
<dd><a class="anchor" id="_todo000016"></a>Provide color management support? Currently, we use the same value for red, green and blue, this might <em>not</em> be perfectly neutral gray depending on the color profile of the monitor…  </dd>
<dt>Class <a class="el" href="class_perceptual_color_1_1_wheel_color_picker.html">PerceptualColor::WheelColorPicker</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000131"></a>BUG: When the hue changes and the gamut gets smaller than the current chroma-lightness value, then the marker is not moved into the new gamut. But it should!</p>
<p class="interdd"><a class="anchor" id="_todo000132"></a>This class is a friend class of <a class="el" href="class_perceptual_color_1_1_chroma_lightness_diagram.html">ChromaLightnessDiagram</a> and of <a class="el" href="class_perceptual_color_1_1_color_wheel.html">ColorWheel</a>. Would it be possible to not rely on this friendship in the code of this class (or at least, to rely less on it)?</p>
<p class="interdd"><a class="anchor" id="_todo000133"></a>Is the (double) focus indicator actually good design? Are there better solutions?</p>
<p class="enddd"><a class="anchor" id="_todo000134"></a>Add <code>whatsThis</code> value explaining the accepted keys and mouse movements (and also to other widgets). </p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
